<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="Note2Flash_logo.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shared Decks - Note2Flash</title>
    <link rel="icon" type="image/png" href="Note2Flash_logo.png" />
    <link rel="stylesheet" href="styles.css" />
    <!-- Font Awesome -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />
    <!-- Firebase SDK -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-analytics.js";
      import { getAuth } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
      import { getFirestore } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

      // Initialize Firebase for shared-decks page
      if (window.firebaseConfig) {
        const app = initializeApp(window.firebaseConfig);
        window.db = getFirestore(app);
        window.auth = getAuth(app);
        console.log("Firebase initialized for shared-decks");
      }
    </script>
    <!-- Other Dependencies -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      .preview-card {
        max-height: 500px;
        margin: 0 auto;
        width: 100%;
        perspective: 1000px;
        cursor: pointer;
      }

      .preview-card-inner {
        position: relative;
        width: 100%;
        height: 400px;
        text-align: center;
        transition: transform 0.8s;
        transform-style: preserve-3d;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .preview-card.flipped .preview-card-inner {
        transform: rotateY(180deg);
      }

      .preview-card-front,
      .preview-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        border-radius: 8px;
        padding: 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        overflow: hidden;
        overflow-wrap: break-word;
        word-wrap: break-word;
      }

      .preview-card-front {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border: 2px solid #dee2e6;
        font-size: 1.2rem;
        line-height: 1.6;
        color: #343a40;
      }

      .preview-card-back {
        background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
        border: 2px solid #28a745;
        transform: rotateY(180deg);
        font-size: 1.1rem;
        line-height: 1.6;
        color: #155724;
      }

      .preview-card-front strong,
      .preview-card-back strong {
        color: #2a7f62;
        display: block;
        margin-bottom: 12px;
        font-size: 1.1em;
      }
      

      .preview-card-front strong,
      .preview-card-back strong {
        color: #2a7f62;
        display: block;
        margin-bottom: 8px;
      }

      /* Ensure modal content can expand */
      .deck-viewer-content {
        max-height: 80vh;
        overflow-y: auto;
      }

      .deck-preview {
        margin-top: 20px;
      }

      /* Deck viewer modal specific styles */
      .deck-viewer-modal {
        margin: 2vh auto !important;
      }

      /* Mobile responsiveness for deck viewer */
      @media (max-width: 768px) {
        .deck-viewer-modal {
          margin: 1rem !important;
          max-width: calc(100vw - 2rem) !important;
          max-height: calc(100vh - 2rem) !important;
          width: calc(100vw - 2rem) !important;
        }

        .preview-card-inner {
          height: 350px;
        }

        .preview-card-front,
        .preview-card-back {
          font-size: 1rem;
          padding: 15px;
        }

        .flip-hint {
          font-size: 0.7rem;
          bottom: 8px;
          right: 12px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Navigation will be loaded here -->
    <div id="nav-placeholder"></div>

    <div class="container">
      <!-- Knowledge Hub -->
      <div class="knowledge-hub">
        <div class="hub-header">
          <h2>Knowledge Hub</h2>
          <p class="hub-description">
            Access specialized flashcard decks for your field of study
          </p>
        </div>

        <div class="category-tabs">
          <button class="category-tab active" data-category="all">
            üìÇ All Trades
          </button>
          <button class="category-tab" data-category="electrician">
            üîå Electricians
          </button>
          <button class="category-tab" data-category="plumber">
            üöø Plumbers / Pipefitters
          </button>
          <button class="category-tab" data-category="hvac">
            ‚ùÑÔ∏è HVAC / Refrigeration
          </button>
          <button class="category-tab" data-category="welder">
            üî• Welders
          </button>
          <button class="category-tab" data-category="carpenter">
            üî® Carpenters
          </button>
          <button class="category-tab" data-category="heavy-equipment">
            üöú Heavy Equipment
          </button>
          <button class="category-tab" data-category="sprinkler">
            üöí Sprinkler Fitters
          </button>
          <button class="category-tab" data-category="sheet-metal">
            üõ†Ô∏è Sheet Metal
          </button>
          <button class="category-tab" data-category="safety">
            üß∞ Safety & OSHA
          </button>
        </div>

        <div class="hub-controls">
          <div class="search-box">
            <input
              type="text"
              id="deckSearch"
              placeholder="Search decks..."
              class="search-input"
            />
            <i class="fas fa-search search-icon"></i>
          </div>
          <div class="hub-actions">
            <!-- Shown when user is logged in -->
            <button
              id="createDeckBtn"
              class="btn btn-primary"
              style="display: none"
            >
              <i class="fas fa-plus"></i> Create Deck
            </button>
            <button
              id="importDeckBtn"
              class="btn btn-secondary"
              style="display: none"
            >
              <i class="fas fa-file-import"></i> Import
            </button>
            <!-- Login to create button removed -->
          </div>
        </div>

        <div class="deck-filters">
          <select id="sortDeck" class="filter-select">
            <option value="recent">Most Recent</option>
            <option value="popular">Most Popular</option>
            <option value="cards">Most Cards</option>
            <option value="rating">Highest Rated</option>
          </select>
          <select id="filterLevel" class="filter-select">
            <option value="all">All Levels</option>
            <option value="beginner">Beginner</option>
            <option value="intermediate">Intermediate</option>
            <option value="advanced">Advanced</option>
          </select>
        </div>

        <div id="savedDecks" class="deck-grid">
          <!-- Decks will be dynamically loaded here -->
        </div>

        <!-- Deck Viewer Modal -->
        <div id="deckViewerModal" class="modal" style="display: none">
          <div
            class="modal-content deck-viewer-modal"
            style="max-width: 900px; max-height: 90vh; overflow-y: auto"
          >
            <span class="close">&times;</span>
            <div class="deck-viewer-header">
              <h2 id="viewerDeckTitle">Deck Title</h2>
              <p id="viewerDeckDescription" class="deck-description">
                Deck description will appear here
              </p>
              <div class="deck-meta">
                <span id="viewerDeckCards" class="deck-cards-count"
                  >0 cards</span
                >
                <span id="viewerDeckLevel" class="deck-card-level"
                  >beginner</span
                >
                <span id="viewerDeckCategory" class="deck-card-category"
                  >category</span
                >
              </div>
            </div>
            <div class="deck-viewer-content">
              <div class="deck-viewer-controls">
                <!-- Primary CTA - most prominent -->
                <button id="studyDeckBtn" class="btn btn-primary btn-large">
                  <i class="fas fa-play"></i> Study This Deck
                </button>
                
                <!-- Secondary CTA - less prominent -->
                <button id="quizDeckBtn" class="btn btn-outline-primary">
                  <i class="fas fa-graduation-cap"></i> Take Quiz
                </button>
                
                <!-- Tertiary action - smallest, contextual -->
                <button id="saveToLibraryBtn" class="btn btn-secondary btn-small">
                  <i class="fas fa-bookmark"></i> Save to Library
                </button>
                
                <!-- Hidden actions - shown conditionally -->
                <button
                  id="importDeckBtnModal"
                  class="btn btn-secondary btn-small"
                  style="display: none"
                >
                  <i class="fas fa-download"></i> Import to My Decks
                </button>
                <button id="loginToSaveandEditBtn" class="btn btn-secondary btn-small" style="display: none">
                  <i class="fas fa-sign-in-alt"></i> Login to Save and Edit
                </button>
              </div>
              <div class="deck-preview">
                <div class="preview-controls">
                  <button id="prevPreviewCard" class="btn btn-secondary">
                    <i class="fas fa-chevron-left"></i>
                  </button>
                  <span id="previewCardNumber">Card 1 of 10</span>
                  <button id="nextPreviewCard" class="btn btn-secondary">
                    <i class="fas fa-chevron-right"></i>
                  </button>
                </div>
                <!-- Preview limit message for non-logged-in users -->
                <div
                  id="previewLimitMessage"
                  class="preview-limit-message"
                  style="display: none"
                >
                  <div class="preview-limit-content">
                    <i class="fas fa-lock"></i>
                    <span
                      >Preview limited to 10 cards.
                      <a href="#" id="signUpForMore" class="preview-signup-link"
                        >Sign up</a
                      >
                      to view all cards and unlock full features!</span
                    >
                  </div>
                  <div class="tooltip-arrow"></div>
                </div>
                <div class="preview-card" id="previewCard">
                  <div class="preview-card-inner">
                    <div class="preview-card-front">
                      <div id="previewCardFront">
                        Card front content will appear here
                      </div>
                      <div class="flip-hint">
                        <i class="fas fa-hand-pointer"></i>
                        Click to flip
                      </div>
                    </div>
                    <div class="preview-card-back">
                      <div id="previewCardBack">
                        Card back content will appear here
                      </div>
                      <div class="flip-hint">
                        <i class="fas fa-hand-pointer"></i>
                        Click to flip back
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Create Deck Modal -->
        <div id="createDeckModal" class="modal" style="display: none">
          <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Create New Deck</h2>
            <form id="createDeckForm">
              <div class="form-group">
                <label for="newDeckName">Deck Name</label>
                <input
                  type="text"
                  id="newDeckName"
                  required
                  placeholder="Enter deck name"
                />
              </div>
              <div class="form-group">
                <label for="deckCategory">Category</label>
                <select id="deckCategory" required>
                  <option value="all">All Trades</option>
                  <option value="electrician">Electricians</option>
                  <option value="plumber">Plumbers / Pipefitters</option>
                  <option value="hvac">HVAC / Refrigeration</option>
                  <option value="welder">Welders</option>
                  <option value="carpenter">Carpenters</option>
                  <option value="heavy-equipment">Heavy Equipment</option>
                  <option value="sprinkler">Sprinkler Fitters</option>
                  <option value="sheet-metal">Sheet Metal</option>
                  <option value="safety">Safety & OSHA</option>
                </select>
              </div>
              <div class="form-group">
                <label for="deckLevel">Difficulty Level</label>
                <select id="deckLevel" required>
                  <option value="beginner">Beginner</option>
                  <option value="intermediate">Intermediate</option>
                  <option value="advanced">Advanced</option>
                </select>
              </div>
              <div class="form-group">
                <label for="deckDescription">Description</label>
                <textarea
                  id="deckDescription"
                  placeholder="Describe your deck..."
                  rows="3"
                ></textarea>
              </div>
              <div class="form-actions">
                <button type="submit" class="btn btn-primary">
                  Create Deck
                </button>
                <button
                  type="button"
                  class="btn btn-secondary"
                  onclick="hideModal('createDeckModal')"
                >
                  Cancel
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>

    <!-- Scripts -->
    <script type="module" src="./config.js"></script>
    <script type="module" src="./deckManager.js"></script>
    <script type="module" src="./app.js"></script>

    <script type="module">
      // Ensure Firebase is initialized after config loads
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
      import { getFirestore } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
      import { getAuth } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

      // Wait for config to be loaded
      setTimeout(() => {
        if (window.firebaseConfig && !window.db) {
          const app = initializeApp(window.firebaseConfig);
          window.db = getFirestore(app);
          window.auth = getAuth(app);
          console.log("Firebase initialized for shared-decks");
        }
      }, 100);
    </script>
    <script type="module">
      import { initializeNavigation } from "./nav-template.js";
      // Initialize navigation as soon as the DOM is ready
      document.addEventListener("DOMContentLoaded", initializeNavigation);
    </script>

    <script>
      // Shared decks page specific functionality
      let currentDeck = null;
      let currentPreviewIndex = 0;

      // Prevent KnowledgeHub auto-initialization to avoid button flashing
      window.disableKnowledgeHubAutoInit = true;

      // Override the global openDeck function to allow unauthenticated access for shared decks
      window.openDeck = function (deckId) {
        console.log("Opening shared deck:", deckId);
        // Find the deck from loaded data
        const deck = window.loadedDecks?.find((d) => d.id === deckId);
        if (deck) {
          openDeckViewer(deck);
        } else {
          showErrorMessage("Deck not found");
        }
      };

      document.addEventListener("DOMContentLoaded", () => {
        // Update UI based on authentication status
        updateUIForAuthStatus();

        // Listen for auth state changes
        if (window.auth) {
          window.auth.onAuthStateChanged((user) => {
            updateUIForAuthStatus();
          });
        }

        // Initialize category tabs
        const categoryTabs = document.querySelectorAll(".category-tab");
        categoryTabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            categoryTabs.forEach((t) => t.classList.remove("active"));
            tab.classList.add("active");
            
            // Use original filtering for shared-decks page
            filterDecksByCategory(tab.dataset.category);
          });
        });

        // Initialize search functionality
        const searchInput = document.getElementById("deckSearch");
        if (searchInput) {
          searchInput.addEventListener("input", (e) => {
            filterDecksBySearch(e.target.value);
          });
        }

        // Initialize deck filters
        const sortSelect = document.getElementById("sortDeck");
        const levelSelect = document.getElementById("filterLevel");
        if (sortSelect) {
          sortSelect.addEventListener("change", () => {
            sortDecks(sortSelect.value);
          });
        }
        if (levelSelect) {
          levelSelect.addEventListener("change", () => {
            filterDecksByLevel(levelSelect.value);
          });
        }

        // Handle login button clicks
        const loginToSaveandEditBtn = document.getElementById(
          "loginToSaveandEditBtn"
        );

        if (loginToSaveandEditBtn) {
          loginToSaveandEditBtn.addEventListener("click", () => {
            if (typeof showAuthModal === "function") {
              showAuthModal();
            } else {
              window.location.href = "/?auth=required";
            }
          });
        }

        // Initialize create deck modal (only shown for logged in users)
        const createDeckBtn = document.getElementById("createDeckBtn");
        const createDeckModal = document.getElementById("createDeckModal");
        if (createDeckBtn && createDeckModal) {
          createDeckBtn.addEventListener("click", () => {
            if (!window.currentUser) {
              if (typeof showAuthModal === "function") {
                showAuthModal();
              } else {
                window.location.href = "/?auth=required";
              }
              return;
            }
            createDeckModal.style.display = "block";
          });
        }

        // Handle sign up link in preview limit message
        document.addEventListener("click", (e) => {
          if (e.target.id === "signUpForMore") {
            e.preventDefault();
            if (typeof showAuthModal === "function") {
              showAuthModal("signup");
            } else {
              window.location.href = "/?auth=signup";
            }
          }
        });

        // Deck Viewer Modal functionality
        initializeDeckViewer();

        // Close modal functionality (for page-specific modals only)
        const closeButtons = document.querySelectorAll(".close");
        closeButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const modal = button.closest(".modal");
            // Only handle non-auth modals here, auth modal handled in app.js
            if (modal && !modal.id.includes("auth")) {
              modal.style.display = "none";
            }
          });
        });

        // Close modal when clicking outside (for page-specific modals only)
        window.addEventListener("click", (e) => {
          const modals = document.querySelectorAll(".modal");
          modals.forEach((modal) => {
            // Only handle non-auth modals here, auth modal handled in app.js
            if (e.target === modal && !modal.id.includes("auth")) {
              modal.style.display = "none";
            }
          });
        });

        // Load shared decks
        loadSharedDecks();
      });

      function updateUIForAuthStatus() {
        const isLoggedIn = window.currentUser;

        // Show/hide appropriate buttons in header
        const createDeckBtn = document.getElementById("createDeckBtn");
        const importDeckBtn = document.getElementById("importDeckBtn");

        if (isLoggedIn) {
          if (createDeckBtn) createDeckBtn.style.display = "block";
          if (importDeckBtn) importDeckBtn.style.display = "block";
        } else {
          if (createDeckBtn) createDeckBtn.style.display = "none";
          if (importDeckBtn) importDeckBtn.style.display = "none";
        }

        // Update deck viewer modal buttons
        const saveToLibraryBtn = document.getElementById("saveToLibraryBtn");
        const importDeckBtnModal =
          document.getElementById("importDeckBtnModal");
        const loginToSaveandEditBtn = document.getElementById(
          "loginToSaveandEditBtn"
        );

        // The Save to Library button is always visible
        // It handles authentication internally
        if (saveToLibraryBtn) {
          saveToLibraryBtn.style.display = "block";
          // Update button text based on login status
          const icon = saveToLibraryBtn.querySelector("i");
          const text = isLoggedIn ? "Save to Library" : "Save to Library";
          saveToLibraryBtn.innerHTML = `<i class="${icon ? icon.className : 'fas fa-bookmark'}"></i> ${text}`;
        }

        // Hide the old buttons - we're using the new consolidated approach
        if (importDeckBtnModal) importDeckBtnModal.style.display = "none";
        if (loginToSaveandEditBtn) loginToSaveandEditBtn.style.display = "none";
      }

      function initializeDeckViewer() {
        const deckViewerModal = document.getElementById("deckViewerModal");
        const studyDeckBtn = document.getElementById("studyDeckBtn");
        const quizDeckBtn = document.getElementById("quizDeckBtn");
        const saveToLibraryBtn = document.getElementById("saveToLibraryBtn");
        const importDeckBtnModal =
          document.getElementById("importDeckBtnModal");
        const prevBtn = document.getElementById("prevPreviewCard");
        const nextBtn = document.getElementById("nextPreviewCard");

        // Study deck button - available to all users
        if (studyDeckBtn) {
          studyDeckBtn.addEventListener("click", () => {
            if (
              currentDeck &&
              currentDeck.cards &&
              currentDeck.cards.length > 0
            ) {
              // Close the modal first
              deckViewerModal.style.display = "none";
              // Start study session directly - no authentication required
              startSharedDeckStudy(currentDeck);
            }
          });
        }

        // Quiz deck button - available to all users
        if (quizDeckBtn) {
          quizDeckBtn.addEventListener("click", () => {
            if (
              currentDeck &&
              currentDeck.cards &&
              currentDeck.cards.length > 0
            ) {
              // Close the modal first
              deckViewerModal.style.display = "none";
              // Start quiz mode
              startQuizMode(currentDeck);
            }
          });
        }

        // Save to Library button - handles authentication
        if (saveToLibraryBtn) {
          saveToLibraryBtn.addEventListener("click", () => {
            if (window.currentUser && currentDeck) {
              // User is logged in, import the deck
              importDeckToMyDecks(currentDeck);
            } else {
              // User not logged in, trigger auth
              if (typeof showAuthModal === "function") {
                showAuthModal();
              } else {
                window.location.href = "/?auth=required";
              }
            }
          });
        }

        // Import deck button - only for logged in users
        if (importDeckBtnModal) {
          importDeckBtnModal.addEventListener("click", () => {
            if (window.currentUser && currentDeck) {
              importDeckToMyDecks(currentDeck);
            }
          });
        }

        // Card flip functionality
        const previewCard = document.getElementById("previewCard");
        if (previewCard) {
          previewCard.addEventListener("click", () => {
            previewCard.classList.toggle("flipped");
          });
        }

        // Preview navigation
        if (prevBtn) {
          prevBtn.addEventListener("click", () => {
            if (currentDeck && currentPreviewIndex > 0) {
              currentPreviewIndex--;
              updatePreviewCard();
              // Reset to show question when navigating
              resetCardDisplay();
            }
          });
        }

        if (nextBtn) {
          nextBtn.addEventListener("click", () => {
            if (
              currentDeck &&
              currentPreviewIndex < currentDeck.cards.length - 1
            ) {
              currentPreviewIndex++;
              updatePreviewCard();
              // Reset to show question when navigating
              resetCardDisplay();
            }
          });
        }
      }

      function openDeckViewer(deck) {
        currentDeck = deck;
        currentPreviewIndex = 0;

        // Update modal content
        document.getElementById("viewerDeckTitle").textContent =
          deck.name || "Untitled Deck";
        document.getElementById("viewerDeckDescription").textContent =
          deck.description || "No description available";
        document.getElementById("viewerDeckCards").textContent = `${
          deck.cards?.length || 0
        } cards`;
        document.getElementById("viewerDeckLevel").textContent =
          deck.metaData?.level || "beginner";
        document.getElementById(
          "viewerDeckLevel"
        ).className = `deck-card-level ${deck.metaData?.level || "beginner"}`;
        document.getElementById("viewerDeckCategory").textContent =
          deck.category || "general";
        document.getElementById(
          "viewerDeckCategory"
        ).className = `deck-card-category ${deck.category || "general"}`;

        // Update preview card
        updatePreviewCard();

        // Reset card display to show question first
        resetCardDisplay();

        // Show modal
        document.getElementById("deckViewerModal").style.display = "block";
      }

      function resetCardDisplay() {
        // Reset to show question state when navigating between cards
        const previewCard = document.getElementById("previewCard");
        if (previewCard) {
          previewCard.classList.remove("flipped");
        }
      }

      function updatePreviewCard() {
        if (
          !currentDeck ||
          !currentDeck.cards ||
          currentDeck.cards.length === 0
        ) {
          document.getElementById("previewCardFront").textContent =
            "No cards available";
          document.getElementById("previewCardBack").textContent =
            "No cards available";
          document.getElementById("previewCardNumber").textContent = "No cards";
          return;
        }

        const isLoggedIn = window.currentUser;
        const maxPreviewCards = isLoggedIn
          ? currentDeck.cards.length
          : Math.min(10, currentDeck.cards.length);
        const totalCards = currentDeck.cards.length;

        // Show preview limit message for non-logged-in users when they have more than 10 cards
        const previewLimitMessage = document.getElementById(
          "previewLimitMessage"
        );
        if (!isLoggedIn && totalCards > 10) {
          previewLimitMessage.style.display = "block";
        } else {
          previewLimitMessage.style.display = "none";
        }

        const card = currentDeck.cards[currentPreviewIndex];

        // Handle different card types for preview
        let frontContent = "No front content";
        let backContent = "No back content";

        if (card.type === "contextual") {
          frontContent = `<strong>Scenario:</strong><br>${
            card.scenario || "No scenario"
          }<br><br><strong>Question:</strong><br>${
            card.question || "No question"
          }`;
          backContent = `<strong>Answer:</strong><br>${
            card.answer || "No answer"
          }${
            card.explanation
              ? `<br><br><strong>Explanation:</strong><br>${card.explanation}`
              : ""
          }`;
        } else if (card.type === "cloze") {
          // For cloze cards, show the front with blanks filled in
          if (card.front) {
            frontContent = card.front.replace(
              /\{([^}]+)\}/g,
              '<span style="text-decoration: underline; font-weight: bold;">_____</span>'
            );
            backContent = card.front.replace(
              /\{([^}]+)\}/g,
              '<span style="color: #2a7f62; font-weight: bold; background-color: rgba(42, 127, 98, 0.1); padding: 2px 4px; border-radius: 3px;">$1</span>'
            );
          }
        } else {
          // For term, qa, and other card types
          frontContent = card.front || "No front content";
          backContent = card.back || "No back content";
        }

        document.getElementById("previewCardFront").innerHTML = frontContent;
        document.getElementById("previewCardBack").innerHTML = backContent;

        // Update card counter display
        if (!isLoggedIn && totalCards > 10) {
          document.getElementById("previewCardNumber").textContent = `Card ${
            currentPreviewIndex + 1
          } of ${maxPreviewCards} (${totalCards} total)`;
        } else {
          document.getElementById("previewCardNumber").textContent = `Card ${
            currentPreviewIndex + 1
          } of ${totalCards}`;
        }

        // Update navigation button states
        const prevBtn = document.getElementById("prevPreviewCard");
        const nextBtn = document.getElementById("nextPreviewCard");

        if (prevBtn) {
          prevBtn.disabled = currentPreviewIndex === 0;
          prevBtn.style.opacity = currentPreviewIndex === 0 ? "0.5" : "1";
        }

        if (nextBtn) {
          // For non-logged-in users, limit to 10 cards
          const maxIndex = isLoggedIn
            ? totalCards - 1
            : Math.min(9, totalCards - 1);
          nextBtn.disabled = currentPreviewIndex >= maxIndex;
          nextBtn.style.opacity = currentPreviewIndex >= maxIndex ? "0.5" : "1";
        }
      }

      function startSharedDeckStudy(deck) {
        // Redirect to pricing page instead of starting study session
        console.log("Redirecting to pricing for shared deck:", deck.name);
        window.location.href = "/pricing.html";
      }

      function startQuizMode(deck) {
        // Store deck data and redirect to quiz page
        console.log("Starting quiz mode for deck:", deck.name);
        sessionStorage.setItem("quizDeck", JSON.stringify(deck));
        window.location.href = "/quiz.html";
      }

      async function importDeckToMyDecks(deck) {
        if (!window.currentUser) {
          if (typeof showAuthModal === "function") {
            showAuthModal();
          }
          return;
        }

        try {
          // Use existing deck management functionality if available
          if (
            typeof window.deckManager !== "undefined" &&
            window.deckManager.importSharedDeck
          ) {
            await window.deckManager.importSharedDeck(deck);
            showSuccessMessage("Deck imported successfully!");
            document.getElementById("deckViewerModal").style.display = "none";
          } else if (
            typeof window.KnowledgeHub !== "undefined" &&
            window.KnowledgeHub.importDeckToLibrary
          ) {
            await window.KnowledgeHub.importDeckToLibrary(deck);
            showSuccessMessage("Deck imported successfully!");
            document.getElementById("deckViewerModal").style.display = "none";
          } else {
            throw new Error("Deck import functionality not available");
          }
        } catch (error) {
          console.error("Error importing deck:", error);
          showErrorMessage("Failed to import deck. Please try again.");
        }
      }

      async function loadSharedDecks() {
        // Show loading state
        const savedDecks = document.getElementById("savedDecks");
        savedDecks.innerHTML =
          '<div class="deck-loading-spinner"><div class="spinner"></div></div>';

        try {
          // Load decks from Firebase
          await loadDecksFromFirebase();
        } catch (error) {
          console.error("Error loading shared decks:", error);
          // Show error message instead of fallback
          savedDecks.innerHTML = `
            <div class="no-decks-message">
              <i class="fas fa-exclamation-triangle"></i>
              <p>Unable to load shared decks. Please check your connection and try again.</p>
              <button class="btn btn-primary" onclick="loadSharedDecks()">
                <i class="fas fa-refresh"></i> Retry
              </button>
            </div>
          `;
        }
      }

      // Helper function to safely parse Firebase date fields
      function parseFirebaseDate(dateField) {
        if (!dateField) {
          return new Date();
        }

        // If it's a Firebase Timestamp object
        if (dateField && typeof dateField.toDate === "function") {
          return dateField.toDate();
        }

        // If it's already a Date object
        if (dateField instanceof Date) {
          return dateField;
        }

        // If it's a string or number, try to parse it
        if (typeof dateField === "string" || typeof dateField === "number") {
          const parsed = new Date(dateField);
          return isNaN(parsed.getTime()) ? new Date() : parsed;
        }

        // Fallback to current date
        return new Date();
      }

      async function loadDecksFromFirebase() {
        try {
          console.log("=== loadDecksFromFirebase() called ===");
          console.log("window.db:", window.db);
          console.log("window.firebaseConfig:", window.firebaseConfig);

          // Check if Firebase is available
          if (!window.db) {
            console.log("Firebase not available, trying to initialize...");

            // Try to wait for config and initialize
            let attempts = 0;
            while (!window.firebaseConfig && attempts < 10) {
              console.log(
                `Waiting for firebaseConfig... attempt ${attempts + 1}`
              );
              await new Promise((resolve) => setTimeout(resolve, 100));
              attempts++;
            }

            if (window.firebaseConfig && !window.db) {
              console.log("Config found, initializing Firebase...");
              const { initializeApp } = await import(
                "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js"
              );
              const { getFirestore } = await import(
                "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js"
              );
              const app = initializeApp(window.firebaseConfig);
              window.db = getFirestore(app);
              console.log("Firebase initialized successfully");
            } else {
              throw new Error("Firebase configuration not available");
            }
          }

          console.log("Querying sharedDecks collection...");
          // Get shared decks from Firebase
          const { collection, getDocs } = await import(
            "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js"
          );
          const querySnapshot = await getDocs(
            collection(window.db, "sharedDecks")
          );

          const firebaseDecks = [];
          querySnapshot.forEach((doc) => {
            const deckData = doc.data();
            console.log(
              "Found deck:",
              deckData.name,
              "Category:",
              deckData.category
            );
            // Convert Firebase deck format with all required properties
            const deck = {
              id: doc.id,
              name: deckData.name || "Untitled Deck",
              description: deckData.description || "No description available",
              category: deckData.category || "general",
              cardCount: deckData.cards ? deckData.cards.length : 0,
              views: deckData.views || 0,
              rating: deckData.rating || 0,
              createdAt: parseFirebaseDate(deckData.createdAt),
              cards: deckData.cards || [],
              tags: deckData.tags || deckData.metaData?.tags || getSampleTagsForCategory(deckData.category),
              metaData: deckData.metaData || {
                level: deckData.level || "beginner",
                tags: deckData.tags || getSampleTagsForCategory(deckData.category),
                isPublic: deckData.isPublic !== false,
                author: deckData.author || "Anonymous",
              },
            };
            firebaseDecks.push(deck);
          });

          console.log(
            `=== Loaded ${firebaseDecks.length} decks from Firebase ===`
          );
          firebaseDecks.forEach((deck) => {
            console.log(
              `- ${deck.name} (${deck.category}, ${deck.cardCount} cards)`
            );
          });

          // Store loaded decks globally for other functions
          window.loadedDecks = firebaseDecks;

          // Display the decks
          displayDecksFromData(firebaseDecks);
        } catch (error) {
          console.error("=== Error loading from Firebase ===", error);
          throw error;
        }
      }

      function displayDecksFromData(decks) {
        console.log("displayDecksFromData called with", decks.length, "decks");
        decks.forEach(deck => {
          const tags = deck.tags || deck.metaData?.tags || [];
          console.log(`Deck: ${deck.name}, Tags: [${tags.join(', ')}]`);
        });
        
        const savedDecks = document.getElementById("savedDecks");

        if (decks.length === 0) {
          savedDecks.innerHTML = `
            <div class="no-decks-message">
              <i class="fas fa-folder-open"></i>
              <p>No shared decks available yet.</p>
              <button class="btn btn-primary" onclick="window.location.href='/'">
                Create Your Own Deck
              </button>
            </div>
          `;
          return;
        }

        savedDecks.innerHTML = decks
          .map(
            (deck) => `
          <div class="deck-card" data-deck-id="${deck.id}">
            <div class="deck-card-level ${
              deck.metaData?.level || "beginner"
            }">${deck.metaData?.level || "beginner"}</div>
            <div class="deck-card-header">
              <h3 class="deck-card-title">${deck.name}</h3>
              <span class="deck-card-category ${deck.category}">${
              deck.category
            }</span>
            </div>
            <p class="deck-card-description">${deck.description}</p>
            ${(deck.tags || deck.metaData?.tags) && (deck.tags || deck.metaData?.tags).length > 0 ? `
              <div class="deck-card-tags">
                ${(deck.tags || deck.metaData?.tags).slice(0, 3).map(tag => `
                  <span class="deck-tag">${tag}</span>
                `).join('')}
                ${(deck.tags || deck.metaData?.tags).length > 3 ? `<span class="deck-tag-more">+${(deck.tags || deck.metaData?.tags).length - 3} more</span>` : ''}
              </div>
            ` : ''}
            <div class="deck-card-stats">
              <div class="deck-card-stat">
                <i class="fas fa-layer-group"></i>
                <span>${deck.cardCount} cards</span>
              </div>
            </div>
          </div>
        `
          )
          .join("");

        // Remove the event listeners for view buttons since they no longer exist
        // Keep the card click functionality
        document.querySelectorAll(".deck-card").forEach((card) => {
          card.addEventListener("click", (e) => {
            if (!e.target.closest("button")) {
              const deckId = card.dataset.deckId;
              const deck = decks.find((d) => d.id === deckId);
              if (deck) {
                openDeckViewer(deck);
              }
            }
          });
        });
      }

      function filterDecksByCategory(category) {
        const deckCards = document.querySelectorAll(".deck-card");
        deckCards.forEach((card) => {
          const deck = window.loadedDecks?.find(
            (d) => d.id === card.dataset.deckId
          );
          if (category === "all" || (deck && deck.category === category)) {
            card.style.display = "block";
          } else {
            card.style.display = "none";
          }
        });
      }

      function filterDecksBySearch(searchTerm) {
        const deckCards = document.querySelectorAll(".deck-card");
        const term = searchTerm.toLowerCase();

        deckCards.forEach((card) => {
          const deck = window.loadedDecks?.find(
            (d) => d.id === card.dataset.deckId
          );
          if (!deck) {
            card.style.display = "none";
            return;
          }

          const searchableText =
            `${deck.name} ${deck.description} ${deck.category}`.toLowerCase();
          if (!term || searchableText.includes(term)) {
            card.style.display = "block";
          } else {
            card.style.display = "none";
          }
        });
      }

      function filterDecksByLevel(level) {
        const deckCards = document.querySelectorAll(".deck-card");
        deckCards.forEach((card) => {
          const deck = window.loadedDecks?.find(
            (d) => d.id === card.dataset.deckId
          );
          const deckLevel = deck?.metaData?.level || "beginner";
          if (level === "all" || deckLevel === level) {
            card.style.display = "block";
          } else {
            card.style.display = "none";
          }
        });
      }

      function sortDecks(sortBy) {
        console.log("Sorting by:", sortBy);

        if (!window.loadedDecks || window.loadedDecks.length === 0) {
          return;
        }

        let sortedDecks = [...window.loadedDecks];

        switch (sortBy) {
          case "cards":
            sortedDecks.sort((a, b) => (b.cardCount || 0) - (a.cardCount || 0));
            break;
          case "popular":
            // Sort by view count (most popular first)
            sortedDecks.sort((a, b) => (b.views || 0) - (a.views || 0));
            break;
          case "rating":
            // Sort by rating (highest first)
            sortedDecks.sort((a, b) => (b.rating || 0) - (a.rating || 0));
            break;
          case "recent":
          default:
            // Sort by creation date (most recent first)
            sortedDecks.sort((a, b) => {
              const dateA = a.createdAt || new Date(0);
              const dateB = b.createdAt || new Date(0);
              return dateB - dateA;
            });
            break;
        }

        // Re-display the sorted decks
        displayDecksFromData(sortedDecks);

        // Reapply current filters
        const activeCategory =
          document.querySelector(".category-tab.active")?.dataset.category ||
          "all";
        const searchTerm = document.getElementById("deckSearch")?.value || "";
        const levelFilter =
          document.getElementById("filterLevel")?.value || "all";

        if (activeCategory !== "all") {
          filterDecksByCategory(activeCategory);
        }
        if (searchTerm) {
          filterDecksBySearch(searchTerm);
        }
        if (levelFilter !== "all") {
          filterDecksByLevel(levelFilter);
        }
      }

      function showSuccessMessage(message) {
        // Use existing success message function or create simple alert
        if (typeof window.showSuccessMessage === "function") {
          window.showSuccessMessage(message);
        } else {
          alert(message);
        }
      }

      function showErrorMessage(message) {
        // Use existing error message function or create simple alert
        if (typeof window.showErrorMessage === "function") {
          window.showErrorMessage(message);
        } else {
          alert(message);
        }
      }

      function getSampleTagsForCategory(category) {
        const categoryTags = {
          electrician: ['ohms-law', 'safety', 'residential', 'circuits', 'nec-code', 'troubleshooting', 'wiring', 'motor-control'],
          plumber: ['pipes', 'pressure', 'troubleshooting', 'tools', 'soldering', 'drainage', 'fittings', 'water-systems'],
          hvac: ['refrigeration', 'seer', 'humidity', 'comfort', 'ductwork', 'heat-pumps', 'airflow', 'thermostats'],
          welder: ['ppe', 'safety', 'arc-welding', 'porosity', 'mig-welding', 'tig-welding', 'metal-prep', 'inspection'],
          carpenter: ['tools', 'cutting', 'framing', 'measurements', 'joinery', 'blueprints', 'safety', 'finishing'],
          'heavy-equipment': ['hydraulics', 'maintenance', 'safety', 'operations', 'troubleshooting', 'inspection'],
          sprinkler: ['fire-safety', 'pressure', 'testing', 'nfpa', 'installation', 'maintenance'],
          'sheet-metal': ['fabrication', 'cutting', 'bending', 'safety', 'tools', 'materials'],
          safety: ['osha', 'fall-protection', 'fatal-four', 'construction', 'ppe', 'hazard-recognition']
        };
        
        const tags = categoryTags[category] || ['general', 'basics', 'fundamentals'];
        // Return 2-4 random tags from the category
        const shuffled = tags.sort(() => 0.5 - Math.random());
        return shuffled.slice(0, Math.floor(Math.random() * 3) + 2);
      }
    </script>

    <script type="module">
      import { initializeFooter } from "./footer-template.js";
      // Initialize footer
      document.addEventListener("DOMContentLoaded", initializeFooter);
    </script>
  </body>
</html>
